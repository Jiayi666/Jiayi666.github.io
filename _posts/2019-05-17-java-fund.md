---
layout:     post
title:      "Java JVM & OOP"
subtitle:   ""
date:       2019-05-17
author:     "Jiayi.Liu"
header-img: "img/post-bg-2015.jpg"
catalog: 	true
tags:
    - Java
    - Programming
---

> This post is highly relied on [this great tutorial](https://www.javatpoint.com/java-tutorial).

> Java is a language high based on the OOP principles, you can't learn Java without learn OOP.


### Java Virtual Machine (JVM)

Higher Level Language Ex. C++, Java

Middle-Level Languages Ex. C

Low-Level Language Ex. Assembly

Finally the lowest level as the Machine Language.

- Compiler: A compiler is a program which converts a program from one level of language to another. Example conversion of C++ program into machine code.
- Interpreter: An interpreter is a program which converts a program at one level to another programming language at the same level. Example conversion of **bytecode into machine code**.

> Java is needs both compiler and interpreter to work. The java compiler converts high-level Java code into bytecode (which is also a type of machine code). The Just In Time Code generator within JVM converts the bytecode into the native machine code which are at the same programming levels.

&nbsp;&nbsp;&nbsp;&nbsp;The problem of using compiler is **different platform use different machine code!** For example the machine code in Mac (A12 processor) is different with Windows (Intel processor) not to mention mobile platforms. So, **the software compile in one platform can't run in another platform!**

&nbsp;&nbsp;&nbsp;&nbsp;JVM is introduced to deal with this. The JAVA compiler won't compile JAVA code into machine language, instead it's compiled to **bytecode** (`.class` files). Then in whatever platform, as long as **JVM is running in the RAM**, the JVM will takecare of platforms and **translate** the bytecode into machine code **as run**. The name Java Virtual Machine just explained it's function!

&nbsp;&nbsp;&nbsp;&nbsp;To see what JVM did while run a Java program, check [this video](https://youtu.be/G1ubVOl9IBw).

### Java Application Schema

- The `main` function in Java is mostly used to **launching** and **testing**. Java application is all about objects (instances) talking to each other, the `main` function is just a start point.

#### Java Vairable

> There are only two kind of variables in Java: **primitive variable** and **object reference**.

&nbsp;&nbsp;&nbsp;&nbsp;Take care that the *value* in reference variable is the *reference* instead of the object.

> Using `new` to allocate space in the heap and when no reference is refering to an object, it is erased by garbage collection algorithm.

&nbsp;&nbsp;&nbsp;&nbsp;The object defined by `new` is in **heap** but its reference is in **stack**.

### Java Class

> A class should define what is **known** (attributes) and what the class **can do** (methods). This should also been followed by Java's naming convintion which always give methods a verb.

- The constructor **has no return type!** even `void`.

#### Static Key Word

> Take care, `static` doesn't equal to `const`. `static` means this variable / method belongs to the class instead of an object.

##### Static variable

&nbsp;&nbsp;&nbsp;&nbsp;A static variable means the variable is **shared** by all instance of this class.

##### Static Method

- A static method can be **invoked without the need for creating an instance** of a class. (This is why the `main` method is always static, because we don't need an object/instance to run it.)
- The static method can not use non static data member or call non-static method directly.
- `this` and `super` cannot be used in static context.

> A static method / variable should be **accessed in a static way**!

&nbsp;&nbsp;&nbsp;&nbsp;As shown above, a static method / variable is a component of the **class** instead of an instance. So, when we try to access a static method / variable, we should do `MyClass.staticMethod()` instead of `object.staticMethod()`. The latter on may work, but it's dangerous and unclear.

##### Static Block

- Is used to initialize the static data member. So, we don't need to type `static` everytime.
- It is executed before the main method at the time of classloading.

#### `final` Keyword

> In Java, **final** means **constant**.

- If you make any variable as final, you cannot change the value of final variable. (including function parameters)
- If you make any method as final, you cannot override it.
- If you make any class as final, you cannot extend it.

#### `this` and `super` Keyword

##### `this` in Java Class

> In java, this is a **reference variable** that refers to the current **object**.

- `this` can be used to refer current class instance variable. (By using `this.varName = varName`, we can distinguish between the instance variable and function input.)
- `this.method()` can be used to invoke current class method (implicitly)
- `this()` can be used to invoke current class constructor. (The real usage of this case is to **reuse constructor in another constructor**.)
- `method(this)` can be passed as an argument in the method call.
- `AnotherClass(this)` can be passed as argument in the constructor call.
- `return this` can be used to return the current class instance from the method.

##### `super` in Java Class

> Whenever you create the instance of subclass, an instance of parent class is created implicitly which is referred by `super` **reference variable**.

&nbsp;&nbsp;&nbsp;&nbsp;The use of `super` is very similar with `this`.

- `super.var` can be used to refer immediate parent class instance variable.
- `super.method()` can be used to invoke immediate parent class method.
- `super()` can be used to invoke immediate parent class constructor.

&nbsp;&nbsp;&nbsp;&nbsp;One most important usage of `super` keyword is to **reuse** the parent's constructor. Check [here](https://www.javatpoint.com/super-keyword) for an example. It seems like the inheritance in Java is letting the subclass object **share** the variables and methods with the implicitly created superclass object.

#### Class Inheritance

> Inheritance represent a **IS A** relationship. It means the subclass **is a** superclass.

&nbsp;&nbsp;&nbsp;&nbsp;The keyword for Java inheritance is `extends` (mind the `s`).

&nbsp;&nbsp;&nbsp;&nbsp;Multiple inheritance (one subclass inheritate from multiple superclass) is not supported in Java.

#### Class Aggregation

> Aggregation represent a **HAS A** relationship. Such as the company class **has a** boss class.

&nbsp;&nbsp;&nbsp;&nbsp;The usage of aggretation is easy, just create an instance in another class.

#### Polymorphism

> **Overloading** means to define multiple method with the same name **in a class**. 

##### Overloading

- By changing number of arguments.
- By changing the parameter type.

&nbsp;&nbsp;&nbsp;&nbsp;Remember that even though we can overload the `main` method, but the JVM only calls the `main` method with `String args[]` parameters.

&nbsp;&nbsp;&nbsp;&nbsp;Take care that when there is an ambiguity in invoking method such as `method(int a, long a)` and `method(long a, int b)` when input is `method(12, 12)` so we don't know witch method to call, there will be a run time error.

##### Overriding

> **Overriding** means to *redefine* a method in **subclass**.

&nbsp;&nbsp;&nbsp;&nbsp;Because by inheritance, the methods in superclass is automatically defined for subclass. So, overriding is just **redefine** the **inheritated method**. In Java, such *redefine* won't cause error if the previous method is inheritated.

&nbsp;&nbsp;&nbsp;&nbsp;Take special care that Java can do **overriding with return type!** But *overloading* with return type isn't allowed because of ambiguity.

// To Continue: last time stop at [here](https://www.javatpoint.com/runtime-polymorphism-in-java)

#####





